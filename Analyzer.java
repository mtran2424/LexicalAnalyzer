/**
 * Representing an analyzer of simple arithmetic expressions. Can perform lexical and
 * syntactical analysis of a given expression.
 * @author My Tran
 * @version 1.0
 */
public class Analyzer 
{
    //members of class analyzer

    /**
     * Member
     * Stores arithmetic expression in the class
     */
    private String expression;

    /**
     * Member
     * Contains the index of our current position in the input string
     */
    private int currentIndex;

    /**
     * Member
     * Represents the current lexeme in the analysis of the input expression
     */
    private String lexeme;

    /**
     * Member
     * Representing the character classification of a character
     */
    private Token charClass;

    /**
     * Member
     * Representing the token of nextChar
     */
    private Token nextToken;

    /**
     * Member
     * Representing the next character
     */
    private char nextChar;


    /**
	 * Non-default Constructor
	 * Constructs a LexicalAnalyzer object with a given expression, formatted and stored in "expression" member
	 * @param input String containing an expression
	 */
    public Analyzer(String input)
    {
        expression = input;
        currentIndex = 0;
        lexeme = "";
        charClass = Token.EOF;
        nextChar = ' ';
    }

    /**
     * Method
     * Performs recursive-decent parse on the expression with the language 
     * generated by the rule:
     * <expr> -> <term> {(+|-) <term>}
     * <term> -> <factor> {(*|/) <factor>}
     * <factor> -> id | int_lit | (<expr>)
     */
    public void parse()
    {
        //if the expression is an empty string, output error
        if(expression.isEmpty())
        {
            System.out.println("ERROR: Empty input string");
        }
        //parse when there is input
        else
        {
            
            getChar();
        
            //if the first charactor is not alphanumeric,
            if(charClass == Token.UNKNOWN)
            {

                //the only valid symbol a first input can be is a open parenthesis
                if(lookUp(nextChar) != Token.LEFT_PAREN)
                {
                    //output read lexeme and error message
                    lex();
                    System.out.println("ERROR: Bad input\n");
                }
                else
                {
                    //otherwise, execute parse
                    do
                    {
                        lex();
                        expr();
                    }while(!isError() && nextToken != Token.EOF);
                }
            }
            //charClass indicates LETTER or DIGIT otherwise
            //execute parse normally
            else
            {
                //accumulate first lexeme and parse while there are still lexemes in the string
                do
                {
                    lex();
                    expr();
                }while(!isError() && nextToken != Token.EOF);
            }
        }
        
    }//end of parse

    /**
     * Method
     * Performs a lexical analysis of the expression stored in this object
     */
    public void analyze()
    {
        //if the expression is an empty string, output error
        if(expression.isEmpty())
        {
            System.out.println("ERROR: Empty input string");
        }
        //perform lexical analysis
        else
        {
        getChar();
        do
        {
            lex();
        }while(!isError() && nextToken != Token.EOF);
        }
    }//end analyze


    /**
     * Method
     * Adds the next character in the input string into the lexeme member
     * which is storing the current lexeme
     */
    private void addChar()
    {
        lexeme += nextChar;
    }//end addChar


    /**
     * Method
     * Sets the character classification member representing the classification of
     * the current character.
     */
    private void getChar()
    {
        //check if current index is within the bounds of the string
        if(currentIndex < expression.length())
        {
            //obtain the next character from the input string and increment to the
            //next index
            nextChar = expression.charAt(currentIndex);
            currentIndex++;
            
            //if nextChar is:
            //a letter then assign the token LETTER
            //a number then assign the token DIGIT
            //a decimal then assign FLOAT_CODE
            //non-alphanumeric then assign UNKNOWN
            if(nextChar >= 'A' && nextChar <= 'z')
            {
                charClass = Token.LETTER;
            }
            else if(nextChar >= '0' && nextChar <= '9')
            {
                charClass = Token.DIGIT;
            }
            else if (nextChar == '.')
            {
                charClass = Token.FLOAT_CODE;
            }
            else
            {
                charClass = Token.UNKNOWN;
            }
        }
        //characters not accounted for above are assigned EOF
        else
        {
            charClass = Token.EOF;
        }
    }//end getChar


    /**
     * Method
     * Skips over whitespace in the input string until a non whitespace
     * character is encountered
     */
    private void getNonBlank()
    {
        while(nextChar == ' ')
        {
            getChar();
        }
    }//end get non blank


    /**
     * Method
     * Accumulates and outputs a lexeme and its corresponding token
     */
    private Token lex()
    {
        //clear the previous lexeme
        lexeme = "";
        getNonBlank();

        //accumulate lexeme based on type of character read
        switch(charClass)
        {
            //if first character of the lexeme is a letter, it is assumed to
            //be an identifier
            case LETTER:
                addChar();
                getChar();
                nextToken = Token.IDENT;
                
                //accumulate consequent alphanumerics
                while(charClass == Token.LETTER || charClass == Token.DIGIT)
                {
                    addChar();
                    getChar();
                }

                //test for reserved words as identifier names
                switch(lexeme)
                {
                    case "for": nextToken = Token.FOR_CODE;
                        break;
                    case "if": nextToken = Token.IF_CODE;
                        break;
                    case "else": nextToken = Token.ELSE_CODE;
                        break;
                    case "do": nextToken = Token.DO_CODE;
                        break;
                    case "while": nextToken = Token.WHILE_CODE;
                        break;
                    case "int": nextToken = Token.INT_CODE;
                        break;
                    case "switch": nextToken = Token.SWITCH_CODE;
                        break;
                    default:
                        break;
                }
                
                break;
            //if the first character is a digit, it is assumed to be an int literal
            case DIGIT:
                addChar();
                getChar();
                nextToken = Token.INT_LIT;
                //accumulate all alphanumericals and decimals
                while(charClass == Token.DIGIT 
                    || charClass == Token.FLOAT_CODE 
                    || charClass == Token.LETTER)
                {
                    //if a decimal or letter is encountered, token is set to FLOAT_CODE
                    if(charClass == Token.FLOAT_CODE || charClass == Token.LETTER)
                    {
                        nextToken = Token.FLOAT_CODE;
                    }

                    addChar();
                    getChar();
                }
                
                break;
            //if non-alphanumeric, look up the character to determine token
            case UNKNOWN:
                lookUp(nextChar);
                getChar();
                break;
            default:
                nextToken = Token.EOF;
                break;
        }

        //output the resultant token and lexeme
        System.out.println("\nNext token is: " + nextToken.toString() + "\nNext lexeme is: " + lexeme + "\n");
        return nextToken;
    }//end lex


    /**
     * Method
     * Determines the lexeme Token given a lexeme input
     * @param input representing a character from an expression
     * @return lexeme Token
     */
    private Token lookUp(char input)
    {
        switch(input)
        {
            case '(':
                addChar();
                nextToken = Token.LEFT_PAREN;
                break;
            case ')':
                addChar();
                nextToken = Token.RIGHT_PAREN;
                break;
            case '+':
                addChar();
                nextToken = Token.ADD_OP;
                break;
            case '-':
                addChar();
                nextToken = Token.SUB_OP;
                break;
            case '*':
                addChar();
                nextToken = Token.MULT_OP;
                break;
            case '/':
                addChar();    
                nextToken = Token.DIV_OP;
                break;
            case '=':
                addChar();    
                nextToken = Token.ASSIGN_OP;
                break;
            default:
                addChar();
                nextToken = Token.EOF;
                break;
        }
        return nextToken;
    }//end lookUp


    /**
     * Method
     * Parses expression in the language generated by the rule: 
     * <expr> -> <term> {(+|-) <term>}
     */
    private void expr()
    {
        System.out.println("Enter <expr>");

        if(!isError())
        {
            //evaluate LHS term(non-terminal)
            term();

            
            
            while((nextToken == Token.ADD_OP || nextToken == Token.SUB_OP))
            {
                //output and evaluate RHS term(non-terminal)
                lex();
                term();
            }
            
        }

        System.out.println("Exit <expr>");
    }//end expr


    /**
     * Method
     * Parses expression in the language generated by the rule: 
     * <term> -> <factor> {(*|/) <factor>}
     */
    private void term()
    {
        System.out.println("Enter <term>");

        if(!isError())
        {
        //evaluate LHS term(non-terminal)
        factor();

        }
        else
        {
            while((nextToken == Token.MULT_OP || nextToken == Token.DIV_OP))
            {
                //output and evaluate RHS term(non-terminal)
                lex();
                factor();
            }
        }
        
        System.out.println("Exit <term>");
    }//end term


    /**
     * Method
     * Parses expression in the language generated by the rule: 
     * <factor> -> id | int_lit | (<expr>)
     */
    private void factor()
    {
        System.out.println("Enter <factor>");

        if(!isError())
        {
            if(nextToken == Token.IDENT || nextToken == Token.INT_LIT)
            {
                lex();
            }
            else if(nextToken == Token.LEFT_PAREN)
            {
                lex();
                expr();
                if((nextToken == Token.RIGHT_PAREN))
                {
                    lex();
                }
            }
            else
            {
                if(isError())
                {
                    lex();
                }

            }
        }
        System.out.println("Exit <factor>");
    }//end factor

    

    /**
     * Method
     * Returns true if error Token passed in is an error.
     * @return true if token is that of an error
     */
    private Boolean isError()
    {
        return (nextToken == Token.FOR_CODE
                || nextToken == Token.IF_CODE
                || nextToken == Token.ELSE_CODE
                || nextToken == Token.WHILE_CODE
                || nextToken == Token.DO_CODE
                || nextToken == Token.INT_CODE
                || nextToken == Token.FLOAT_CODE
                || nextToken == Token.SWITCH_CODE
                || nextToken == Token.EOF
                || nextToken == Token.ASSIGN_OP);
    }//end isError

}
